## 驱动表与被驱动表
给出chatgpt关于驱动表与被驱动表的解释：
> 在 SQL 查询中，当涉及到多个表之间的关联查询时，其中一个表的数据可以被用来驱动查询，而另一个表则被驱动。这个驱动表和被驱动表之间的关系是查询优化的一个重要方面。
> 驱动表是查询中第一个被访问的表，该表的数据会被用来驱动整个查询过程。当驱动表中的行匹配被驱动表中的行时，被驱动表中的相应行将被检索出来。**驱动表通常是数据量较小的表**，可以快速找到匹配的行。在多表关联查询中，优化器会自动选择哪个表作为驱动表。
> 被驱动表是查询中第二个及以后被访问的表，该表的数据会根据驱动表中的数据进行匹配，以获取查询所需的结果。被驱动表通常是数据量较大的表，因此需要通过优化来提高查询性能。
> 在进行 SQL 查询时，驱动表和被驱动表之间的选择非常重要，这会影响查询的性能。选择一个合适的驱动表可以减少被驱动表的扫描次数，从而提高查询性能。因此，优化驱动表和被驱动表之间的关系可以通过**创建适当的索引、使用子查询、缓存结果**等方式来实现。同时，了解查询中每个表的特点可以更好地优化查询，从而提高查询性能。

**一句话总结：驱动表是数据量较小的表，被驱动表是被匹配的表。**
## Nested Loop Join (NLJ)算法
> Nested Loop Join 是 SQL 查询优化中一种基本的关联操作算法，用于将两个表中的数据进行匹配以得到所需的结果。在 Nested Loop Join 算法中，对于每一行驱动表（outer table）的记录，都需要在被驱动表（inner table）中遍历一遍，以找到符合 JOIN 条件的记录。
> 具体来说，Nested Loop Join 算法的执行过程如下：
> 1. 首先，选择一个作为驱动表（outer table）的表，通常是数据量较小的表。
> 2. 遍历驱动表中的每一行，并将其中的关联字段（join key）的值用于在被驱动表（inner table）中进行查找。
> 3. 对于每一个在被驱动表中找到的匹配行，将它们与驱动表的当前行进行 JOIN 操作，并将 JOIN 的结果添加到最终结果集中。
> 4. 当驱动表中的所有行都被处理完毕后，算法结束并返回最终结果集。
>
需要注意的是，Nested Loop Join 算法的性能受到驱动表和被驱动表的大小和索引的影响。如果被驱动表中的数据量很大，那么算法的效率就会非常低下。为了提高 Nested Loop Join 算法的性能，可以考虑**为关联字段创建适当的索引、调整查询顺序、使用过滤条件**等方式。
> 总的来说，Nested Loop Join 算法是 SQL 查询优化中一种基本的关联操作算法，它通过在驱动表和被驱动表之间进行嵌套循环遍历来实现 JOIN 操作。虽然 Nested Loop Join 算法的执行效率相对较低，但它的实现简单，适用于大多数关联查询场景。

**一句话总结：遍历驱动表，在被驱动表中匹配并添加到结果集中，时间复杂度为O(mn),**
## Simple Nested-Loop Join（SNLJ）
> Simple Nested-Loop Join是一种基本的Join算法之一，也是最简单的一种Join算法。它的基本思想是将两个表的每一行都与另一个表的所有行进行比较，找到满足Join条件的行组合。其具体过程如下：
> 1. 从表R中取出第一行r1。
> 2. 对于r1，遍历表S中的所有行，找到与r1匹配的行组合，并将其添加到结果集中。
> 3. 重复步骤1和步骤2，直到表R的所有行都被遍历完。
>
Simple Nested-Loop Join的时间复杂度为O(m_n)，其中m和n分别是表R和表S的行数。在最坏情况下，需要执行m_n次比较。因此，Simple Nested-Loop Join只适用于较小的表或者对Join结果没有性能要求的情况。如果表的规模很大，使用Simple Nested-Loop Join可能会导致性能问题。
> 需要注意的是，在实际应用中，Simple Nested-Loop Join可能会被优化，例如通过使用索引来加速表的访问。此外，还有其他更高效的Join算法可供选择，例如Sort Merge Join、Hash Join等。

**一句话总结：无索引时的NLJ**
## Block Nested Loop Join （BNLJ）
> Block Nested Loop Join（BNL Join）是一种关系型数据库系统中的连接操作，它可以将两个表格（关系）中的数据按照给定的连接条件进行匹配，产生一个新的结果表格。
> 在BNL Join中，首先选择一个表格作为外层循环（outer loop），另一个表格作为内层循环（inner loop）。然后，将外层表格中的一部分数据（也称为块）加载到内存中，同时扫描内层表格，将符合连接条件的数据进行匹配。当内层表格扫描完毕后，再将外层表格中的下一块数据加载到内存中，直到所有的数据都被处理完毕。

**一句话总结：将驱动表部分数据存到join buffer中，以减少内循环的次数**

## Index Join
> Index Join是一种使用索引来加速Join操作的算法，它的基本思想是通过索引来查找Join条件匹配的行，而不是对表进行全表扫描。具体来说，Index Join的过程如下：
> 1. 首先，对Join条件涉及的属性建立索引。这可以通过使用CREATE INDEX语句来完成。
> 2. 然后，将查询转换为包含Join条件的查询，同时使用索引来加速查询。如果有多个Join条件，可以使用多个索引。
> 3. 当查询执行时，数据库系统会使用索引来查找Join条件匹配的行。如果两个表都有索引，通常会先选择较小的表进行查找。对于较小的表，可以使用索引快速定位符合Join条件的行，然后在另一个表中查找匹配的行。
> 4. 如果Join条件匹配的行较少，那么使用索引的效果会非常明显。但如果Join条件匹配的行较多，那么使用索引的效果可能不如其他Join算法（如Hash Join和Sort Merge Join）。
>
需要注意的是，索引Join适用于Join条件中涉及到的属性已经建立索引的情况。如果Join条件中的属性没有建立索引，则无法使用Index Join。此外，对于大型表或高基数的列，使用索引可能会导致性能问题，因此需要根据实际情况进行权衡和优化。

### 失效
> 虽然Index Join可以加速Join操作，但是在某些情况下，它可能会失效，导致性能下降。下面是一些常见的Index Join失效情况：
> 1. Join条件不使用索引列：如果Join条件中的列没有建立索引，或者使用的不是索引列，那么Index Join将失效。在这种情况下，可以考虑为Join条件中的列建立索引，或者使用其他Join算法。
> 2. 非等值Join条件：如果Join条件不是等值条件（如>, <, >=, <=），那么Index Join将失效。在这种情况下，可以使用其他Join算法，如Sort Merge Join。
> 3. 有多个Join条件：如果Join条件包含多个列，而只有一部分列被索引，那么Index Join可能会失效。在这种情况下，可以尝试建立覆盖索引（Covering Index），即包含所有Join条件列和需要查询的列的索引。
> 4. 数据分布不均匀：如果Join的两个表中有一个表的数据分布非常不均匀，那么Index Join可能会失效。例如，如果一个表中的大多数行都与另一个表的大多数行匹配，那么使用Index Join将不如使用其他Join算法。在这种情况下，可以考虑使用其他Join算法，或者重新设计表的结构。
> 5. 使用了函数或表达式：如果Join条件中使用了函数或表达式，那么Index Join可能会失效。在这种情况下，可以考虑使用派生列（Derived Column）或持久化计算列（Persisted Computed Column）来保存函数或表达式的结果，并为其建立索引。

**一句话总结：利用索引进行关联，加速匹配，注意失效情况**

## Sort Merge Join
> Sort Merge Join是一种基于排序的Join算法，它可以用于没有索引或者索引不能提供足够优化的Join操作。
> Sort Merge Join的过程分为两个阶段：排序阶段和合并阶段。
> 1. 排序阶段：
>
首先，将需要Join的两个表按照Join条件中的列进行排序。例如，如果Join条件是"table1.column1 = table2.column2"，那么需要对table1和table2分别按照column1和column2进行排序。
> 1. 合并阶段：
>
在排序完成后，将排序后的两个表进行合并。具体过程如下：
> - 定义两个指针p1和p2，分别指向table1和table2的第一行。
> - 比较p1和p2指向的行的Join条件列的值。如果相等，则输出Join结果；如果不相等，则将值较小的指针后移一位，再进行比较。
> - 重复上述过程，直到p1或p2指向了其表的最后一行。
>
Sort Merge Join的优点是可以处理大数据量的Join操作，而且不需要使用索引。缺点是需要进行排序操作，因此可能会消耗大量的内存和CPU资源。另外，在Join条件列分布不均匀的情况下，Sort Merge Join的效率可能不如其他Join算法。需要根据具体情况进行选择和优化。

**一句话总结：排序后用指针比较join条件列，排序消耗资源，且不适合join条件列分布不均匀的情况**
## Hash Join
> Hash Join是一种基于哈希表的Join算法，它可以用于处理大数据量的Join操作，通常比Sort Merge Join更快。
> Hash Join的过程分为两个阶段：构建哈希表和查找匹配行。
> 1. 构建哈希表：
>
首先，将需要Join的两个表中的Join条件列进行哈希运算，并将结果保存在哈希表中。例如，如果Join条件是"table1.column1 = table2.column2"，那么需要对table2中的column2进行哈希运算，并将结果存储在哈希表中。具体步骤如下：
> - 从table2中读取每一行数据。
> - 对column2进行哈希运算，得到哈希值h。
> - 将h作为键，将整行数据作为值，存储在哈希表中。
>
在构建哈希表的过程中，如果遇到哈希冲突，需要将冲突的数据保存在同一个桶中。通常，哈希表的桶数是根据数据量和内存大小来动态调整的。
> 1. 查找匹配行：
>
在哈希表构建完成后，需要在table1中查找与table2匹配的行。具体步骤如下：
> - 从table1中读取每一行数据。
> - 对Join条件列进行哈希运算，得到哈希值h。
> - 在哈希表中查找是否存在哈希值为h的桶。
> - 如果存在，则遍历桶中的每一行数据，与当前行进行Join操作。如果符合Join条件，则输出Join结果。
> - 重复上述过程，直到table1中的所有行都被处理完毕。
>
Hash Join的优点是可以处理大数据量的Join操作，而且不需要进行排序操作，因此通常比Sort Merge Join更快。缺点是需要消耗大量的内存来构建哈希表，因此可能会受限于内存大小。另外，在哈希冲突较多的情况下，Hash Join的效率可能不如其他Join算法。需要根据具体情况进行选择和优化。

**一句话总结：构建hash表，遍历驱动表计算哈希值匹配hash表总的桶**

